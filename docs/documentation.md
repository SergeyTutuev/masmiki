# Документация
## Функциональности
1) Хранение больших целых знаковых чисел
2) Преобразование машинного слова в тип большого числа
3) Основные операции
	1) Сложение, вычитание, умножение, целочисленное деление, деление с остатком больших чисел
	2) Битовые сдвиги (shl и shr) большого числа на большое число бит
	3) Возведение большого числа в степень большого числа
	4) Наибольший общий делитель (gcd) большого числа
	5) Взятие модуля большого числа
	6) Смена знака большого числа на противоположный
4) Операции сравнения больших чисел
5) Ввод большого числа в консоль в десятичной системе счисления
6) Вывод большого числа в консоль в десятичной системе счисления

## Техническое устройство
- [Стиль кода](../codestyle.md).
- Используемое соглашение о вызовах `stdcall`.
- Для каждой функции используется свой модуль. Функции, отвечающие за смежные операции, находятся в одной папке (например, `addBI` и `subBI` в папке `arithmetic`).
- [Обработка ошибок](#механизм-ошибок)
## Сущности
- Для хранения больших чисел будет использоваться структура `BigInt: {size, ptr}`, состоящая из двух полей: `size` (количество машинных слов, занимаемых этим числом) и `ptr` (указатель на начало байтов (в Big-Endian) хранимого числа в памяти). Число в памяти будет хранится в дополнительном коде. Для того или иного объявленного большого числа (объекта структуры BigInt) знак будет храниться в первом (старшем) бите блока памяти, выделенного под данное число (если этот бит равен 1 - то число отрицательное, в противном случае - положительное).

## Список вспомогательных процедур
#### Процедура определения знака числа
###### BigIntSign
На вход процедуры поступает большое число - объект структуры `BigInt`. Значение старшего бита записывается в флаг знака `sf`. 
#### Процедура перевода из прямого кода в дополнительный код
###### NegBigInt
Если старший (знаковый) бит в блоке хранения числа равен 1, то инвертируем все биты в данном блоке (кроме старшего) и прибавляем к результату инверсии 1.
#### Процедура сравнения размеров операндов
###### CompareBigIntSizes
Данная процедура вызывается перед выполнением кода алгоритма любой бинарной операции. Сравнивается поле `size` поданных на вход операндов любой бинарной операции. Если значения данных полей не равны - процедура завершается, выдавая соответствующий код ошибки в `ax`.


## Список алгоритмов
#### Алгоритм перевода строки в BigInt
Конвертирует десятичную строку в структуру `BigInt`.  

---
###### StringToBigInt
- `str` — входная ASCII-строка (`['+'|'-']? '0'…'9'+`)
- `buffer_ptr` — указатель на статически выделенный под число блок памяти (Big-Endian)
- `size` — количество машинных слов, доступных по `buffer_ptr`
- `result` — выходная структура `BigInt`
###### Задействованные флаги
- `of` - флаг переполнения
- `cf` - флаг переноса
---

1. Разбор знака:
   1. Считать первый символ.
   2. Если это `'-'`, то установить `is_neg = 1`, иначе `is_neg = 0`.
   3. Иначе проверить, что первый символ - цифра (от `0` до `9`). Если это не так, выдать сигнал ошибки: выставить флаг `CF` в `1`, выполнить выход.
2. Заполнить `size` слов нулями (`buffer_ptr[i] = 0`).
3. Для каждой цифры в строке (слева направо) добавить в `buffer_ptr` текущую цифру. Если очередной символ не является цифрой, выдать сигнал ошибки: выставить флаг `CF` в `1`, выполнить выход.
4. Если `is_neg = 1` - перевести в дополнительный код (функция `NegBigInt`).
5. Проверка переполнения: если выделенной памяти недостаточно для хранения числа, выдать сигнал ошибки: флаг `OF` выстановлен в `1` после работы функции ввода.
6. Сформировать результат:
   1. `result.size = size`
   2. `result.ptr = buffer_ptr`


#### Алгоритм ввода числа c консоли
###### InputBigInt
- `str_buf` — указатель на символьный буфер, выделенный пользователем для хранения вводимой строки.
- `str_buf_size` — размер буфера `str_buf` в байтах.
- `buffer_ptr` — указатель на предварительно выделенный блок памяти под число (Big-Endian).
- `size` — количество машинных слов, доступных по адресу `buffer_ptr`.
- `result` — структура `BigInt`, в которую будет записан результат.
---
1. Очистить `buffer_ptr`: записать нули в `size` слов.
2. Выделить символьный буфер `str_buf` длиной `str_buf_size`.
3. Чтение строки с консоли:
   1. Считывать символы с клавиатуры до ввода `CR` ("возврат каретки" - `0Dh`).
   2. Сохранять считанные символы в буфер `str_buf`.
4. Вызов `StringToBigInt`. Передать в неё `str_buf`, `buffer_ptr`, `size`, `result`. 
5. Проверка флагов после завершения:
   1. Если `CF = 1` - ошибка формата, выход.
   2. Если `OF = 1` - переполнение, выход.
6. Сформировать результат:
   1. `result.ptr = buffer_ptr`
   2. `result.size = size`


#### Алгоритм вывода числа в консоль
Преобразует значение `BigInt` в десятичную строку, выводит полученную строку в консоль

---
###### OutputBigInt
- `num` — структура `BigInt`
- `str_out` — буфер-приёмник ASCII-символа
---

1. Считать старший бит самого левого байта.
   Если он равен 1, то установить `is_neg = 1`. Иначе - `is_neg = 0`.  
2. Если `is_neg = 1`, преобразовать число в прямой код (инвертировать все биты и прибавить 1).  
   Результат поместить во временный буфер `tmp`.
3. Пока `tmp` не станет нулём:  
   1. Разделить `tmp` на 10, получив частное и остаток.  
   2. Сохранить символ остатка (одну цифру) в конец массива `digits`.  
   3. Заменить `tmp` на полученное частное.
4. Если ни одной цифры не получено, записать `'0'` в `digits`.
5. Сформировать строку:
   1. Если исходное число было отрицательным, добавить `'-'` в `str_out` и вывести его.  
   2. Проходимся по всем элементам `digits` (от последней сохранённой цифры к первой):
		1. Кладём элемент из `digits` в `str_out`
		2. Выводим `str_out`
   3. Вывести символы перехода на новую строку:  
      - `0Dh` (Carriage Return)  
      - `0Ah` (Line Feed)




### Описание алгоритмов
#### Алгоритм сложения
Реализуется алгоритм сложения длинных чисел.

---
###### AddBigInt
- `num1` - первое слагаемое (BigInt)
- `num2` - второе слагаемое (BigInt)
- `result` - структура, в которую будет записан результат (BigInt) 
###### Задействованные флаги
- `zf` - флаг нуля результата
- `sf` - флаг знака результата
- `of` - флаг переполнения
- `pf` - флаг чётности (числа единичных битов в младшем байте переменной `result` после выполнения алгоритима)
---
1. Обнулить `result`.
2. Запускаем цикл i = от size (кол-во слов в `num1` и `num2`) до 0:
    1. выполняем сложения слов `num1[i]` + `num2[i]` + перенос из прошлого сложения и кладем в `result[i]`
---
После выполнения `result` содержит искомую сумму `num1` и `num2`.  
В соответствии со значением переменной `result` флаги устанавливаются следующим образом:
- Флаг `sf` - устанавливается в 1, если значение `result` отрицательное, 0 - в противном случае
- Флаг `pf` - устанавливается в 1, если число единичных битов в младшем байте переменной `result` чётное, 0 - в противном случае
- Флаг `zf` - устанавливается в 1, если значение `result` равно 0, 0 - в противном случае
- Флаг `of` - устанавливается в 1, если произошло переполнение, 0 - в противном случае


#### Алгоритм вычитания
Реализуется алгоритм вычитания длинных чисел через приведение к сложению с противоположным числом.

---
###### SubtractBigInt
- `num1` — уменьшаемое (BigInt)
- `num2` — вычитаемое (BigInt)
- `result` — структура, в которую будет записан результат (BigInt)
###### Задействованные флаги
- `zf` - флаг нуля результата
- `sf` - флаг знака результата
- `of` - флаг переполнения
- `pf` - флаг чётности (числа единичных битов в младшем байте переменной `result` после выполнения алгоритима)
---
1. Вычислить число `num2_neg`, противоположное числу `num2`
2. Сложить `num1` и `num2_neg`, сохранить сумму в `result`
---
Структура `result` содержит искомую разность `num1` и `num2`.  
В соответствии со значением переменной `result` флаги устанавливаются следующим образом:
- Флаг `sf` - устанавливается в 1, если значение `result` отрицательное, 0 - в противном случае
- Флаг `pf` - устанавливается в 1, если число единичных битов в младшем байте переменной `result` чётное, 0 - в противном случае
- Флаг `zf` - устанавливается в 1, если значение `result` равно 0, 0 - в противном случае
- Флаг `of` - устанавливается в 1, если произошло переполнение, 0 - в противном случае

#### Алгоритм умножения
Реализуется алгоритм умножения длинных чисел «в столбик» (long multiplication)

---
###### MultiplyBigInt
- `num1` — первый множитель (BigInt)
- `num2` — второй множитель (BigInt)
- `result` — структура, в которую будет записан результат (BigInt)
###### Задействованные флаги
- `zf` - флаг нуля результата
- `sf` - флаг знака результата
- `of` - флаг переполнения
- `pf` - флаг чётности (числа единичных битов в младшем байте переменной `result` после выполнения алгоритима)
---
1. Обнулить `result`.
2. Для каждого бита `num2` (от младшего к старшему) выполнить:
	1. Если текущий бит `num2` установлен (равен 1), прибавить `num1` к `result` с помощью функции сложения sum.
	2. Сдвинуть `num1` влево на 1 бит (умножить на 2).
---
Структура `result` содержит произведение `num1 * num2`.  
В соответствии со значением переменной `result` флаги устанавливаются следующим образом:
- Флаг `sf` - устанавливается в 1, если значение `result` отрицательное, 0 - в противном случае
- Флаг `pf` - устанавливается в 1, если число единичных битов в младшем байте переменной `result` чётное, 0 - в противном случае
- Флаг `zf` - устанавливается в 1, если значение `result` равно 0, 0 - в противном случае
- Флаг `of` - устанавливается в 1, если произошло переполнение, 0 - в противном случае


#### Алгоритм нахождения НОД
Реализуется [ускоренный алгоритм Евклида](https://ru.algorithmica.org/cs/modular/euclid/).

---
###### GcdBigInt 
- `num1` — первый аргумент (BigInt)
- `num2` — второй аргумент (BigInt)
- `result` — структура, в которую будет записан результат (BigInt)
###### Задействованные флаги
- `zf` - флаг нуля (`result` может принять значение 0, если `num1` и `num2` будут равны 0)
- `pf` - флаг чётности (числа единичных битов в младшем байте переменной `result` после выполнения алгоритима)

---

1. Сохранить максимум из `num1` и `num2` в переменную `result`
2. Сохранить минимум из `num1` и `num2` во вспомогательную переменную `b` типа BigInt
3. Пока `b` не равно 0, выполнять:
	1. Записать значение `b` во вспомогательную переменную `temp` типа BigInt	
	2. Произвести остаточное деление `result` на `b` и результат записать в `b`
	3. Значение переменной `temp` записать в `result`
---
Структура `result` содержит наибольший общий делитель чисел `num1` и `num2`.  
В соответствии со значением переменной `result` флаги устанавливаются следующим образом:
- Флаг `pf` - устанавливается в 1, если число единичных битов в младшем байте переменной `result` чётное, 0 - в противном случае
- Флаг `zf` - устанавливается в 1, если значение `result` равно 0, 0 - в противном случае

#### Алгоритм сравнения
Реализуется алгоритм сравнения двух длинных чисел на основе вычитания.

---
###### CompareBigInt
- `num1` — первое число (BigInt)
- `num2` — второе число (BigInt)
###### Задействованные флаги
Флаги выставляются в соответствии с их выставлением при использовании обычной операции сравнения `cmp` в `x86`
- `sf` - флаг знака результата
- `zf` - флаг нуля результата
- `of` - флаг переполнения результата
- `cf` - флаг переноса
---
1. Если `num1` и `num2` разных знаков,то записываем во флаг `sf` инвертированное значение знакового бита переменной `num1`, в `cf` устанавливаем заначение знакового бита `num1`, флаг `of` сбрасываем и завершаем алгоритм, в противном случае - переходим к следующему шагу. 
2. Запускаем цикл `i` = от `1` до `size*16` (не включительно, проходимся по битам сравниваемых числел):

	1. Если `num1.data[i] == num2.data[i]`, увеличиаем `i` на `1`, после этого проверяем: если `i` достигло значения `size*16`, устанавливаем флаг `zf`, сбрасываем `cf`.
	2. Иначе если `num1.data[i] > num2.data[i]`, устанавливаем флаг `sf`, выходим из цикла, сбрасываем `cf`.
	3. Иначе если `num1.data[i] < num2.data[i]`, выходим из цикла, устанавливаем `cf`.
	4. Если оба знаковых бита `num1` и `num2` равны `1` и `sf` установлен, или оба знаковых бита `num1` и `num2` равны `0` и `sf` не установлен, то устанавливаем `of`. В противном случае - сбрасываем `of`.
---
После выполнения алгоритма флаги устанавливаются следующим образом:
- Флаг `sf` - устанавливается, если `num1 ≥ num2`
- Флаг `zf` - устанавливается, если `num1 = num2`
- Флаг `cf` - устанавливается если бы произошёл заём при выполнении вычитания из значения `num1` значения `num2`.
- Флаг `of` - устанавливается если бы произошло переполнение при выполнении вычитания из значения `num1` значения `num2`.



#### Алгоритм целочисленного деления
Реализуется алгоритм деления «в столбик» для длинных чисел.

---
###### DivideBigInt
- `num1` — делимое (BigInt)
- `num2` — делитель (BigInt)
- `result` — структура, в которую будет записано частное (BigInt)
---
1. Проверить, равен ли `num2` нулю:
	1. Если равен — завершить выполнение с выдачей соответствующего исключения.
	2. Если не равен — продолжить выполнение алгоритма.
2. Инициализировать переменную `current` для хранения промежуточного остатка.
3. Инициализировать `result` пустым значением.
4. Для каждой цифры `num1` слева направо выполнять:
	1. Добавить текущую цифру к `current` (сдвинув её в конец).
	2. Инициализировать счётчик вычитаний `count` значением 0.
	3. Пока `current ≥ num2`, выполнять:
		1. Вычесть `num2` из `current`.
		2. Увеличить `count` на 1.
	4. Добавить `count` как очередную цифру к `result`.
5. Определить знак `result`:
	1. Получить знаки `num1` и `num2` с помощью функции определения знака.
	2. Если знаки равны — `result` положительное.
	3. Если знаки различаются — `result` отрицательное.
---
Структура `result` содержит результат целочисленного деления `num1` на `num2`.


#### Алгоритм вычисления остатка от деления
Реализуется алгоритм вычисления остатка от деления с приведением к евклидовому остатку (всегда `0 ≤ r < |b|`).

---
- `num1` — делимое (BigInt)
- `num2` — делитель (BigInt)
- `result` — структура, в которую будет записан остаток (BigInt)
---
###### ModBigInt
1. Проверить, равен ли `num2` нулю:
	1. Если равен — завершить выполнение с выдачей соответствующего исключения.
	2. Если не равен — продолжить выполнение алгоритма.
2. Выполнить целочисленное деление `num1` на `num2`, сохранить частное в `quotient`
3. Умножить `quotient` на `num2`, сохранить произведение в `product`
4. Вычесть `product` из `num1`, сохранить разность в `result`
5. Если `result` отрицателен:
	1. Если `num2` положительное — прибавить `num2` к `result`
	2. Если `num2` отрицательное — вычесть `num2` из `result`
---
Структура `result` содержит произведение остаток от деления `num1` на `num2`.


#### Алгоритм возведения числа в степень
Реализуется алгоритм бинарного возведения в степень

---
###### PowBigInt
- `base` - основание степени (BigInt)
- `exp` - показатель степени (BigInt)
- `result` — структура, в которую будет записан результат (BigInt)
###### Задействованные флаги
- `sf` - флаг знака результата
- `zf` - флаг нуля результата
- `of` - флаг переполнения
- `pf` - флаг чётности

---
1. Инициализировать `result` значением 1
2. Скопировать `base` в отдельную переменную `power`
3. Пока `exp ≠ 0`, выполнять:
	1. Проверить, установлен ли младший бит `exp`
	2. Если младший бит установлен, то умножить `result` на `power`, сохранить результат в `result`
	3. Возвести `power` в квадрат
	4. Выполнить сдвиг `exp` вправо на 1 бит
---
Структура `result` содержит значение `base^exp`.
В соответствии со значением с переменной `result` флаги устанавливаются следующим образом:
- Флаг `sf` - устанавливается, если результат отрицательный
- Флаг `zf` - устанавливается, если результат равен 0
- Флаг `of` - устанавливается, если было переполнение при возведении в степень
- Флаг `pf` - устанавливается, если в младшем байте чётное количество битов, установленных в 1


#### Алгоритмы битовых сдвигов
Реализуются алгоритмы поразрядных битовых сдвигов вправо и влево.

###### ShrBigInt
---
- `source` - изменяемое число (BigInt)
- `bitCount` - величина сдвига (BigInt)
- `result` - структура, в которую будет записан результат (BigInt)
###### Задействованные флаги
- `sf` - флаг знака результата
- `zf` - флаг нуля результата
- `pf` - флаг чётности
- `of` - флаг переполнения
- `cf` - флаг переноса
---

1. Обнулить `result`.
2. Запускаем цикл i = от `bitCount` до `size*16` (не включительно, проходимся по **битам** числа):
    1. Устанавливаем `result.data[i] = source.data[i-bitCount]` (здесь индексация данных числа описана по **битам**)
3. После выполнения `result` содержит искомый результат битового сдвига
4. В соответствии со значением переменной `result` флаги устанавливаются следующим образом:
- Флаг `sf` - устанавливается, если результат отрицательный
- Флаг `zf` - устанавливается, если результат равен 0
- Флаг `pf` - устанавливается, если в младшем байте чётное количество битов, установленных в 1
- Флаг `of` - если был выполнен сдвиг на 1 бит, то устанавливается, если изменилось значение старшего бита, и сбрасывается, если старший бит не изменился, для сдвигов на несколько бит, флаг `of` неопределен.
- Флаг `cf` - становится равным младшему биту операнда до выполнения сдвига.

###### ShlBigInt
---
- `source` - изменяемое число (BigInt)
- `bitCount` - величина сдвига (BigInt)
- `result` - структура, в которую будет записан результат (BigInt)
###### Задействованные флаги
- `sf` - флаг знака результата
- `pf` - флаг чётности
- `of` - флаг переполнения
- `cf` - флаг переноса
---

1. Обнулить `result`.
2. Запускаем цикл i = от `size*16-bitCount` до `0` (включительно, проходимся по **битам** числа):
    1. Устанавливаем `result.data[i] = source.data[i+bitCount]` (здесь индексация данных числа описана по **битам**)
3. После выполнения `result` содержит искомый результат битового сдвига
4. В соответствии со значением переменной `result` флаги устанавливаются следующим образом:
- Флаг `sf` - устанавливается, если результат отрицательный
- Флаг `pf` - устанавливается, если в младшем байте чётное количество битов, установленных в 1
- Флаг `of` - если был выполнен сдвиг на 1 бит, то устанавливается, если изменилось значение старшего бита, и сбрасывается, если старший бит не изменился, для сдвигов на несколько бит, флаг `of` неопределен.
- Флаг `cf` - становится равным старшему биту операнда до выполнения сдвига.


#### Алгоритм взятия модуля
Реализуется алгоритм определения модуля числа.

###### AbsBigInt
---
- `source` - изменяемое число (BigInt)
- `result` — структура, в которую будет записан результат (BigInt)
###### Задействованные флаги
- `sf` - флаг знака результата
---

1. Записать значение переменной `source` в переменную `result`.
2. С помощью процедуры BigIntSign определяем знак переменной `source`.
	1. Если число отрицательное, то с помощью процедуры NegBigInt перевести переменную `result` из дополнительного кода в прямой.
	2. Установить старший (знаковый) бит числа в 0.
---
Структура `result` содержит значение модуля переменной `source`.                                 
В соответствии с алгоритмом флаги устанавливаются следующим образом:
- Флаг `sf` - устанавливается, если в переменной `source` было записано отрицательное значение.



## Механизм ошибок
- Для индикации того, что при выполнении функции произошла ошибка, используется регистр флагов.
- Более конкретно, в результате операции выставляются флаги `OF`, `SF`, `ZF`, `AF`, `CF`, `PF` в соответствии с назначением каждого из них так же, как при выполнении операций над обычными числами.
- При делении (или вычислении остатка от деления) большого числа на `0` (большое число) вызывается прерывание `int 0h` так же, как и при делении на ноль обычных чисел в реальном режиме работы процессора.
- При вызове `InputBigInt`, если переданного количества `size` машинных слов в буфере недостаточно, то после выполнения функции флаг `OF` является выставленным в `1`. Если введённое число имеет неверный формат, то флаг `CF` является выставленным в `1`.
